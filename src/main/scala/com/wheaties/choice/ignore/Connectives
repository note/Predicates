package com.wheaties.choice.ignore

import com.wheaties.logical.Connective

object IgnoreConLL extends Connective[IgnoreL,IgnoreL,IgnoreL]{
  def and(p: IgnoreL, q: IgnoreL) = new IgnoreL {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: IgnoreL, q: IgnoreL) = new IgnoreL {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: IgnoreL, q: IgnoreL) = new IgnoreL {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: IgnoreL, q: IgnoreL) = new IgnoreL {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: IgnoreL, q: IgnoreL) = new IgnoreL {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: IgnoreL, q: IgnoreL) = new IgnoreL {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConSS[V1, V2 >: V1] extends Connective[IgnoreS[V1],IgnoreS[V2],IgnoreS[V1]]{
  def and(p: IgnoreS[V1], q: IgnoreS[V2]) = new IgnoreS[V1] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: IgnoreS[V1], q: IgnoreS[V2]) = new IgnoreS[V1] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: IgnoreS[V1], q: IgnoreS[V2]) = new IgnoreS[V1] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: IgnoreS[V1], q: IgnoreS[V2]) = new IgnoreS[V1] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: IgnoreS[V1], q: IgnoreS[V2]) = new IgnoreS[V1] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: IgnoreS[V1], q: IgnoreS[V2]) = new IgnoreS[V1] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConLS[V] extends Connective[IgnoreL,IgnoreS[V],Ignore[V]]{
  def and(p: IgnoreL, q: IgnoreS[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: IgnoreL, q: IgnoreS[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: IgnoreL, q: IgnoreS[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: IgnoreL, q: IgnoreS[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: IgnoreL, q: IgnoreS[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: IgnoreL, q: IgnoreS[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConSL[V] extends Connective[IgnoreS[V],IgnoreL,Ignore[V]]{
  def and(p: IgnoreS[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: IgnoreS[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: IgnoreS[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: IgnoreS[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: IgnoreS[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: IgnoreS[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConCL[V] extends Connective[Ignore[V],IgnoreL,Ignore[V]]{
  def and(p: Ignore[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: Ignore[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: Ignore[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: Ignore[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: Ignore[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: Ignore[V], q: IgnoreL) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConLC[V] extends Connective[IgnoreL,Ignore[V],Ignore[V]]{
  def and(p: IgnoreL, q: Ignore[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: IgnoreL, q: Ignore[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: IgnoreL, q: Ignore[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: IgnoreL, q: Ignore[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: IgnoreL, q: Ignore[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: IgnoreL, q: Ignore[V]) = new Ignore[V] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConCS[V1,V2 >: V1] extends Connective[Ignore[V1],IgnoreS[V2],Ignore[V1]]{
  def and(p: Ignore[V1], q: IgnoreS[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: Ignore[V1], q: IgnoreS[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: Ignore[V1], q: IgnoreS[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: Ignore[V1], q: IgnoreS[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: Ignore[V1], q: IgnoreS[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: Ignore[V1], q: IgnoreS[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConSC[V1, V2 >: V1] extends Connective[IgnoreS[V1],Ignore[V2],Ignore[V1]]{
  def and(p: IgnoreS[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: IgnoreS[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: IgnoreS[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: IgnoreS[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: IgnoreS[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: IgnoreS[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}

class IgnoreConCC[V1, V2 >: V1] extends Connective[Ignore[V1],Ignore[V2],Ignore[V1]]{
  def and(p: Ignore[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) and (q scheme)
  }

  def or(p: Ignore[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) or (q scheme)
  }

  def xor(p: Ignore[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) xor (q scheme)
  }

  def nand(p: Ignore[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nand (q scheme)
  }

  def nor(p: Ignore[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nor (q scheme)
  }

  def nxor(p: Ignore[V1], q: Ignore[V2]) = new Ignore[V1] {
    protected[choice] def scheme = (p scheme) nxor (q scheme)
  }
}